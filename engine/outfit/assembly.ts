import { Garment, Context, UserProfile, Outfit } from './models';
import { scoreOutfit } from './outfit_scoring';
import { ALGO_PARAMS } from './constants';
import { HardFilter } from './filters';

// Template Definitions (can be moved to constants)
const OUTFIT_TEMPLATES: Record<string, string[]> = {
    // Simple fallback templates
    "default": ["top", "bottom", "footwear"],
    "layering": ["top", "bottom", "layer", "footwear"],
    "one_piece": ["one_piece", "footwear"]
};

interface BeamNode {
    items: Garment[];
    itemScores: number[]; // Scores of individual items
    totalScore: number;
}

export class OutfitAssembler {
    /**
     * Beam Search Assembly
     * @param candidates Map of type -> Garment[] (already scored/filtered)
     * @param candidateScores Map of garmentId -> score
     * @param ctx Context
     * @param user UserProfile
     */
    static assembleOutfits(
        candidates: Record<string, Garment[]>,
        candidateScores: Record<string, number>,
        ctx: Context,
        user: UserProfile
    ): Outfit[] {

        // Determine Template based on Context
        // Simplistic selection
        let template = OUTFIT_TEMPLATES["default"];
        if (ctx.season === 'winter' || ctx.temp < 15) {
            template = OUTFIT_TEMPLATES["layering"];
        }
        // Check for women/dress preference?
        // Assuming defaults for now.

        const BEAM_WIDTH = ALGO_PARAMS.BEAM_WIDTH;

        // Initialize Beam
        // Start with the first slot in template
        const firstSlot = template[0];
        const initialCandidates = candidates[firstSlot] || [];

        // Initial nodes
        let beam: BeamNode[] = initialCandidates.map(g => ({
            items: [g],
            itemScores: [candidateScores[g.id] || 0],
            totalScore: candidateScores[g.id] || 0 // Initial score approximates final
        }));

        // Sort and Prune
        beam.sort((a, b) => b.totalScore - a.totalScore);
        beam = beam.slice(0, BEAM_WIDTH);

        // Expand slot-by-slot
        for (let i = 1; i < template.length; i++) {
            const nextSlot = template[i];
            const nextCandidates = candidates[nextSlot] || [];

            const nextBeam: BeamNode[] = [];

            for (const node of beam) {
                for (const nextGarment of nextCandidates) {
                    // Hard Filter: Combination Veto (Section 4)
                    // Check against ALL existing items in node
                    let isValid = true;
                    for (const existingItem of node.items) {
                        if (!HardFilter.isCombinationValid(existingItem, nextGarment)) {
                            isValid = false;
                            break;
                        }
                    }
                    if (!isValid) continue;

                    // Create new node
                    const newItems = [...node.items, nextGarment];
                    const newItemScores = [...node.itemScores, candidateScores[nextGarment.id] || 0];

                    // Calculate Partial Outfit Score
                    const newTotalScore = scoreOutfit(newItems, newItemScores, user, ctx);

                    nextBeam.push({
                        items: newItems,
                        itemScores: newItemScores,
                        totalScore: newTotalScore
                    });
                }
            }

            // Sort and Prune Next Beam
            nextBeam.sort((a, b) => b.totalScore - a.totalScore);
            beam = nextBeam.slice(0, BEAM_WIDTH);
        }

        // Convert BeamNodes to Outfits
        return beam.map((node, index) => ({
            outfitId: `outfit_${Date.now()}_${index}`,
            items: node.items.map(g => g.id),
            score: node.totalScore,
            badges: [], // TODO: Add badges logic
            rationale: "Generated by AI" // Placeholder, will be filled by explanation layer
        }));
    }
}
